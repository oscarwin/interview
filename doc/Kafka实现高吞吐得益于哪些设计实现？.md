## Kafka 实现高吞吐得益于哪些设计实现？

1) Kafka 采用批量的方式来传输消息，客户端每次会攒一波再一起发送给 broker，减少了频繁的网络传输。服务端也不会将这批量的消息解开，一直到消费者来取消失时也是将这一批消息一次性发给 consumer。

2) Kafka 采用顺序写磁盘，具体的实现就是对于每个分区，将收到的消息顺序写文件，一个文件写满写下一个文件。读的时候也是按顺序读。

3) 利用 PageCache 加速读写。操作系统写文件或者读文件都需要通过 PageCache 来中转，读文件时如果在 PageCache 中命中就不读磁盘了，否者发生一个缺页中断，操作系统将数据从磁盘先加载到 PageCache 中。写文件时，数据也是先写到 PageCache 中，操作系统有一个后台线程会将 PageCache 中的脏页不断刷到磁盘里。PageCache 内存不够了就会淘汰一部分数据，淘汰的算法就是 LRU 或者其变种。Kafka 利用这种特性尽可能命中 PageCache 来减少真正的磁盘 IO。

4) 零拷贝技术。服务端发送数据给消费者需要进过3个步骤。

(1) 将数据从磁盘加载到 PageCache 中，如果 PageCache 缓存命中，则这步省略；

(2) 将数据从 PageCache 的内核空间拷贝到用户空间；

(3) 发送数据，将用户空间的数据拷贝到套接字的内核空间；

零拷贝技术就是将步骤2和3合起来，直接将数据从 PageCache 中拷贝到套接字的输出缓存区中，这样减少一次数据拷贝。

零拷贝的系统调用为：

```
#include <sys/socket.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);

```