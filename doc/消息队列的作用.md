## 消息队列的作用

**异步处理**

对于复杂的业务场景，一次请求需要经历多个链路的调用，同步调用所有的链路会使得处理的速度变慢，进而限制了系统整体的吞吐量。可以将同步调用的方式转换成异步化，降低请求耗时，从而提高接口的性能和系统的吞吐量。

![消息队列-异步](https://github.com/oscarwin/interview/blob/master/img/消息队列-异步.png)

如上图所示，假设某服务需要经历 A、B、C 三次调用，A 调用 B 的平均时间是50ms，B 调用 C 的平均时间是200ms，整个链路的耗时是250ms。主要耗时的地方在于 B 调用 C，因此可以将这个请求异步化。具体的做法就是，B 将请求放入消息队列后直接返回，C 从消息队列不断取消息并进行处理。写入消息队列的速度一般很快，假设平均5ms，那么这个调用的耗时就从250ms优化到了55ms。

**削峰填谷**

高并发的情况下，服务网关可以将请求写入消息队列，服务器从消息队列取消息并处理请求。服务器处理后的消息怎么通知到前端呢？服务网关在发送消息的时候，给每一个请求标识一个唯一 ID ，并将这个 ID 随消息一起发送到消息队列。服务器处理完请求后，然后通过 RPC 调用服务网关提供的 response 接口。服务网关的 response 接口会根据请求的唯一ID来识别是哪个请求完成了，然后拼接返回数据返回给前端。如果发生超时，网关则响应用户一个超时的返回码。因为，消息队列和服务网关本身能够接受海量请求，业务方不用担心这两者的性能。下面有个图，可以帮助你理解。

![消息队列-削峰](https://github.com/oscarwin/interview/blob/master/img/消息队列-削峰.png)

**服务解耦**

在微服务架构的模式下，一个大的系统被拆解为多个小的服务，服务与服务之间可以通过消息队列来解耦。比如微博服务，一个用户发送一条微博以后，可以通过消息队列分别将其发送给消息推送系统，数据统计系统，内容审核系统等。

![消息队列-解耦](https://github.com/oscarwin/interview/blob/master/img/消息队列-解耦.png)

如上图所示，A服务完成请求后需要分别调用 B 服务和 C 服务给其发通知，这时有一个新的服务 D 也需要接入该系统，那么服务 A 就必须要修改代码、测试、上线，成本很大。因此可以通过消息队列进行解耦，A 作为生产者每次处理完请求后向消息队列发送一条消息，B 服务和 C 服务订阅这个主题消息。如果新服务 D 需要接入，只需要订阅这个主题消息即可，对于服务 A、B、C 无任何影响。

**信息收集**

比如上报监控数据、统计数据等。

**限流**

消息队列可以通过令牌桶的方式现实限流。单独启用一个服务，按照一个固定的速率向消息队列中添加令牌桶消息，服务方在处理请求前先要从消息队列取令牌，如果能取到令牌则处理该请求，否则拒绝这次请求。

**事务消息实现分布式事务**

在分布式系统中，经常需要调用其他的服务，如何保证两个服务之间的数据一致性呢？比如电商的订单系统中，订单系统创建一个订单后发一条消息给对账系统。如果先创建订单再发消息，就可能出现订单创建成功但是消息发送失败的情况，这会导致对账数据错误。如果先发消息再创建订单，就可能出现消息发成功但是订单创建失败的情况。

分布式事务事务的实现方法有 2PC(Two-phase commit，两阶段提交)、TCC(Try-Confirm-Cancel)和事务消息，前两种方法多用于同步场景，事务消息则一般用于异步场景。

修改为分布式消息后，上面的场景就变为：

1 开启事务消息

2 发送半消息

3 开启本地事务创建订单

4 如果订单创建成功则提交事务消息，否则回滚事务消息

这样就可以保证订单创建和消息发送的一致性，当然这里还有一个问题需要解决，那就是事务消息的提交失败怎么办？

对于这个问题，Kafka 的解决方案是直接抛异常或错误码，RocketMQ 的解决方案是 Broker 定期查询本地事务的提交状态来决定提交还是回滚。

## 参考

李玥 《消息队列高手课》